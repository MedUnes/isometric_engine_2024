{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://isometric_game_2024_04/./draw.ts","webpack://isometric_game_2024_04/./grid-point.ts","webpack://isometric_game_2024_04/./grid.ts","webpack://isometric_game_2024_04/./isometric.ts","webpack://isometric_game_2024_04/webpack/bootstrap","webpack://isometric_game_2024_04/./game.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Draw = void 0;\nclass Draw {\n    static clear(canvas) {\n        canvas.clear();\n    }\n    static drawGrid(grid, canvas) {\n        grid.forEach(row => {\n            row.forEach(col => {\n                const east = col.neighbours(grid).east;\n                if (east) {\n                    canvas.drawLine(col.coords, east.coords);\n                }\n                const south = col.neighbours(grid).south;\n                if (south) {\n                    canvas.drawLine(col.coords, south.coords);\n                }\n            });\n        });\n    }\n    static drawFilledRectangle(cells, grid, canvas) {\n        cells.forEach(cell => {\n            const n = cell.hasFourNeighbours(grid);\n            if (!n) {\n                return;\n            }\n            // why am I doing a * -1 on y??\n            canvas.drawFilledPolygon([n.topLeft, n.topRight, n.bottomRight, n.bottomLeft].map(cell => ({ x: cell.coords.x, y: cell.coords.y })));\n        });\n    }\n}\nexports.Draw = Draw;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GridPoint = void 0;\n/**\n * Represents a point on the map.\n * Each point has a single height.\n * Four points would make a cell, which will be represented by another object\n */\nclass GridPoint {\n    constructor(x, y, isometric) {\n        this.x = x;\n        this.y = y;\n        this.isometric = isometric;\n        this.isFilled = false;\n        this.height = 0;\n        this.baseCoords = this.isometric.coords(x, y);\n        this.height = Math.floor(Math.random() * 2 - 2);\n        if (x === 0 && y === 0) {\n            this.height = 0;\n        }\n        this.coords = { x: this.baseCoords.x, y: this.baseCoords.y + this.height * -15 };\n    }\n    neighbours(grid) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        return {\n            north: (_b = (_a = grid[this.y - 1]) === null || _a === void 0 ? void 0 : _a[this.x]) !== null && _b !== void 0 ? _b : null,\n            east: (_d = (_c = grid[this.y]) === null || _c === void 0 ? void 0 : _c[this.x + 1]) !== null && _d !== void 0 ? _d : null,\n            south: (_f = (_e = grid[this.y + 1]) === null || _e === void 0 ? void 0 : _e[this.x]) !== null && _f !== void 0 ? _f : null,\n            west: (_h = (_g = grid[this.y]) === null || _g === void 0 ? void 0 : _g[this.x - 1]) !== null && _h !== void 0 ? _h : null,\n        };\n    }\n    /**\n     * When updating coordinatings, I might want to have a side-effect, to update the bounding box for these coordinates\n     * @param newCoords\n     */\n    updateCoords(newCoords) {\n    }\n    increaseHeight() {\n        this.height -= 1;\n        this.coords.y = this.baseCoords.y + this.height * 15;\n        console.log(this);\n    }\n    hasFourNeighbours(grid) {\n        var _a;\n        const topLeft = this;\n        const topRight = this.neighbours(grid).east;\n        const bottomLeft = this.neighbours(grid).south;\n        const bottomRight = (_a = bottomLeft === null || bottomLeft === void 0 ? void 0 : bottomLeft.neighbours(grid).east) !== null && _a !== void 0 ? _a : null;\n        if (!topLeft || !topRight || !bottomLeft || !bottomRight) {\n            return null;\n        }\n        const result = {\n            topLeft, topRight, bottomLeft, bottomRight\n        };\n        return result;\n    }\n    neighbourCoords(grid, boundingGridPoints) {\n        return {\n            topLeft: boundingGridPoints.topLeft.coords,\n            topRight: boundingGridPoints.topRight.coords,\n            bottomLeft: boundingGridPoints.bottomLeft.coords,\n            bottomRight: boundingGridPoints.bottomRight.coords,\n        };\n    }\n    isPointInsideCell(point, grid) {\n        const boundingGridPoints = this.hasFourNeighbours(grid);\n        if (!boundingGridPoints) {\n            // this is some special case where we don't have four points. It would be an edge piece\n            return;\n        }\n        const points = this.neighbourCoords(grid, boundingGridPoints);\n        const topLine = this.getLineParameters(points.topLeft, points.topRight);\n        const bottomLine = this.getLineParameters(points.bottomLeft, points.bottomRight);\n        const leftLine = this.getLineParameters(points.topLeft, points.bottomLeft);\n        const rightLine = this.getLineParameters(points.topRight, points.bottomRight);\n        return !this.pointIsAboveLine(point, topLine) &&\n            this.pointIsAboveLine(point, bottomLine) &&\n            this.pointIsAboveLine(point, leftLine) &&\n            !this.pointIsAboveLine(point, rightLine);\n    }\n    /**\n     * given some line and a point, check if the point is above or below the line\n     * @param x\n     * @param line\n     */\n    pointIsAboveLine(x, line) {\n        /**\n         * The line has equation y = ax + b, with a and b known.\n         * For this point (x, y), substitute in x, to see where y would be, for this x value, if it were on the line.\n         * then this y value can be compared with the actual y value of the point.\n         */\n        const yOnLine = line.a * x.x + line.b;\n        const isAboveLine = x.y <= yOnLine;\n        return isAboveLine;\n    }\n    /**\n     * given two points, I need to know the parameters that define the line between those points.\n     * e.g. x1 = (x, y), x2 = (x', y') then there's a line between those two points\n     * the line is y = ax + b\n     * This function returns a and b.\n     */\n    getLineParameters(x1, x2) {\n        if (x1.x === x2.x) {\n            throw new Error(\"vertical line. I need to handle this with a special case.\");\n        }\n        const a = (x1.y - x2.y) / (x1.x - x2.x);\n        const b = x1.y - x1.x * a;\n        return { a, b };\n    }\n}\nexports.GridPoint = GridPoint;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Grid = void 0;\nconst grid_point_1 = require(\"./grid-point\");\nconst isometric_1 = require(\"./isometric\");\nclass Grid {\n    constructor(width, height) {\n        this.isometric = new isometric_1.Isometric();\n        this.grid = Array.from(Array(height), (_, row) => {\n            return Array.from(Array(width), (_, col) => {\n                const cell = new grid_point_1.GridPoint(col, row, this.isometric);\n                return cell;\n            });\n        });\n    }\n    closestViaIntersection(x, y, grid) {\n        const possibleClosest = this.grid.flat().filter(cel => {\n            const neighbours = cel.hasFourNeighbours(grid);\n            if (!neighbours) {\n                return false;\n            }\n            const isWithinBoundingCorners = neighbours.topLeft.coords.x < x\n                && neighbours.bottomRight.coords.x > x\n                && neighbours.bottomLeft.coords.y > y // y counts from top of screen. Value increases as we go down the screen\n                && neighbours.topRight.coords.y < y;\n            return isWithinBoundingCorners;\n        });\n        const found = possibleClosest.filter(cell => {\n            return cell.isPointInsideCell({ x, y }, grid);\n        });\n        return found[0];\n    }\n    closestPoint(x, y) {\n        return this.closestViaIntersection(x, y, this.grid);\n        // const closest = this.grid.find(row => {\n        //   const c = row.find(cel => {\n        //     return x > cel.coords.x && y > cel.coords.y\n        //   });\n        //   return c;\n        // });\n        // const c = this.grid.reduce((closest, row) => {\n        // }, null as null | GridPoint)\n        // const closest = this.isometric.inverse(x, y);\n        // return closest;\n    }\n}\nexports.Grid = Grid;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Isometric = void 0;\n/**\n * This class represents the grid as an isometric form.\n */\nclass Isometric {\n    get c1() {\n        return [2 * this.xStep, 2 * this.xStep, 0];\n    }\n    get c2() {\n        return [-1 * this.yStep, this.yStep, 0];\n    }\n    // constructor(private xStep = 14,\n    //   private yStep = 10) {}\n    constructor(xStep = Math.sqrt(3) * 10, yStep = 10 * 2) {\n        this.xStep = xStep;\n        this.yStep = yStep;\n    }\n    /**\n     * return screen coordinates for any x/y grid pair\n     * @param x\n     * @param y\n     * @returns\n     */\n    coords(x, y) {\n        /**\n         * This comes from so me linear algebra.\n         * Basically map grid coordinates to isometric coordinates, make some linear equations, and then solve them\n         */\n        return {\n            x: x * this.c1[0] + y * this.c1[1] + this.c1[2],\n            y: x * this.c2[0] + y * this.c2[1] + this.c2[2],\n        };\n    }\n    inverse(x, y) {\n        const yGrid = (this.c2[0] * (this.c1[2] - x) + this.c1[0] * (y - this.c2[2])) /\n            (this.c1[0] * this.c2[1] - this.c2[0] * this.c1[1]);\n        const xGrid = (y - this.c2[2] - yGrid * this.c2[1]) / this.c2[0];\n        return {\n            y: Math.floor(xGrid),\n            x: Math.floor(yGrid),\n        };\n    }\n}\nexports.Isometric = Isometric;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Canvas = exports.Game = void 0;\nconst draw_1 = require(\"./draw\");\nconst grid_1 = require(\"./grid\");\nclass Game {\n    constructor(width = 10, height = 10) {\n        this.grid = new grid_1.Grid(width, height);\n        console.log(this.grid);\n    }\n}\nexports.Game = Game;\nclass Canvas {\n    constructor(onClick, screen = { x: 0, y: 0 }) {\n        this.screen = screen;\n        const canvas = document.getElementById(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) {\n            throw new Error(\"oh no. No canvas found.\");\n        }\n        this.ctx = ctx;\n        canvas.onclick = (event) => {\n            console.log(`x: ${event.offsetX} y: ${event.offsetY}`);\n            onClick(event.offsetX, event.offsetY);\n        };\n    }\n    drawLine(from, to) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.translateX(from.x), this.translateY(from.y));\n        this.ctx.moveTo(this.translateX(from.x), this.translateY(from.y));\n        this.ctx.lineTo(this.translateX(to.x), this.translateY(to.y));\n        this.ctx.stroke();\n    }\n    drawFilledPolygon(points) {\n        console.log(points);\n        const region = new Path2D();\n        region.moveTo(points[0].x, points[0].y);\n        points.slice(1).forEach(p => {\n            region.lineTo(p.x, p.y);\n        });\n        // region.lineTo(points[0].x, points[0].y);\n        region.closePath();\n        this.ctx.fillStyle = \"green\";\n        this.ctx.fill(region);\n        // this.test();\n    }\n    test() {\n        const region = new Path2D();\n        region.moveTo(30, 90);\n        region.lineTo(110, 20);\n        region.lineTo(240, 130);\n        region.lineTo(60, 130);\n        region.lineTo(190, 20);\n        region.lineTo(270, 90);\n        region.closePath();\n        this.ctx.fillStyle = \"green\";\n        this.ctx.fill(region, \"evenodd\");\n    }\n    clear() {\n        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n    }\n    moveScreen(x, y) {\n        this.screen.x += x;\n        this.screen.y += y;\n    }\n    translateX(x) {\n        return x + this.screen.x;\n    }\n    translateY(y) {\n        return y + this.screen.y;\n    }\n}\nexports.Canvas = Canvas;\nconst game = new Game(30, 30);\nconst canvas = new Canvas((x, y) => {\n    const closest = game.grid.closestPoint(x, y);\n    closest\n        ? console.log(`found: x: ${closest.x} y: ${closest.y}`)\n        : console.log('none found');\n    if (closest) {\n        game.grid.grid[closest.y][closest.x].isFilled = !game.grid.grid[closest.y][closest.x].isFilled;\n    }\n    const filled = game.grid.grid.flat().filter(cell => cell.isFilled);\n    draw_1.Draw.clear(canvas);\n    draw_1.Draw.drawFilledRectangle(filled, game.grid.grid, canvas);\n    drawGrid();\n}, { x: 0, y: 0 });\nconst drawGrid = () => draw_1.Draw.drawGrid(game.grid.grid, canvas);\ndrawGrid();\n"],"names":["Object","defineProperty","exports","value","Draw","clear","canvas","drawGrid","grid","forEach","row","col","east","neighbours","drawLine","coords","south","drawFilledRectangle","cells","cell","n","hasFourNeighbours","drawFilledPolygon","topLeft","topRight","bottomRight","bottomLeft","map","x","y","GridPoint","constructor","isometric","this","isFilled","height","baseCoords","Math","floor","random","_a","_b","_c","_d","_e","_f","_g","_h","north","west","updateCoords","newCoords","increaseHeight","console","log","neighbourCoords","boundingGridPoints","isPointInsideCell","point","points","topLine","getLineParameters","bottomLine","leftLine","rightLine","pointIsAboveLine","line","yOnLine","a","b","x1","x2","Error","Grid","grid_point_1","isometric_1","width","Isometric","Array","from","_","closestViaIntersection","flat","filter","cel","closestPoint","c1","xStep","c2","yStep","sqrt","inverse","yGrid","xGrid","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","module","__webpack_modules__","draw_1","grid_1","game","onClick","screen","document","getElementById","ctx","getContext","onclick","event","offsetX","offsetY","to","beginPath","moveTo","translateX","translateY","lineTo","stroke","region","Path2D","slice","p","closePath","fillStyle","fill","test","clearRect","moveScreen","closest","filled"],"sourceRoot":""}